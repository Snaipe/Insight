/*
 * This file is part of Insight.
 *
 * Copyright Â© 2015 Franklin "Snaipe" Mathieu <http://snaipe.me>
 *
 * Insight is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Insight is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Insight.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
#ifndef INSIGHT_TYPES_HH
# define INSIGHT_TYPES_HH

# include <string>
# include <cassert>
# include "range"
# include "insight"

namespace Insight {

    class NamespaceInfo;
    class Container;

    class Named {
    public:
        virtual const std::string& name() const = 0;
    };

    class TypeInfo : virtual public Named {
    public:
        virtual size_t size_of() const = 0;
        virtual Container& parent() const = 0;

        inline bool operator==(const TypeInfo& rhs) const;
    };

    enum PrimitiveKind {
        UNKNOWN = 0,

        VOID,
        BOOL,
        CHAR,
        INT,
        FLOAT,
        DOUBLE,

        UNSIGNED                = 1 << 8,
        SHORT                   = 1 << 9,
        LONG                    = 1 << 10,
        LONG_LONG               = 1 << 11,
        COMPLEX                 = 1 << 12,

        SHORT_INT               = SHORT | INT,
        LONG_INT                = LONG | INT,
        LONG_LONG_INT           = LONG_LONG | INT,

        UNSIGNED_CHAR           = UNSIGNED | CHAR,
        UNSIGNED_SHORT_INT      = UNSIGNED | SHORT_INT,
        UNSIGNED_INT            = UNSIGNED | INT,
        UNSIGNED_LONG_INT       = UNSIGNED | LONG_INT,
        UNSIGNED_LONG_LONG_INT  = UNSIGNED | LONG_LONG_INT,

        LONG_DOUBLE             = LONG | DOUBLE,

        FLOAT_COMPLEX           = COMPLEX | FLOAT,
        DOUBLE_COMPLEX          = COMPLEX | DOUBLE,
        LONG_DOUBLE_COMPLEX     = COMPLEX | LONG_DOUBLE,

    };

    class PrimitiveTypeInfo : virtual public TypeInfo {
    public:
        virtual PrimitiveKind kind() const = 0;
    };

    class StructInfo;

    class Child {
    public:
        virtual Container& parent() const = 0;
    };

    class MemberInfo : virtual public Named, virtual public Child {
    public:
        virtual StructInfo& declaring_type() const;
    };

    class TypedInfo : virtual public Child {
    public:
        virtual TypeInfo& type() const = 0;
    };

    class FieldInfo : virtual public TypedInfo, virtual public MemberInfo {
    public:
        virtual size_t offset() const = 0;

        template<typename V, typename T>
        void set(T& instance, V value) const {
            assert(type_of(T) == declaring_type());
            assert(type_of(V) == type());
            V* target = reinterpret_cast<V*>(reinterpret_cast<char*>(&instance) + offset());
            *target = value;
        }

        template<typename V, typename T>
        V& get(T& instance) const {
            assert(type_of(T) == declaring_type());
            assert(type_of(V) == type());
            return *reinterpret_cast<V*>(reinterpret_cast<char*>(&instance) + offset());
        }
    };

    class VariableInfo : virtual public TypedInfo, virtual public Named {
    public:
        virtual void* address() const = 0;

        template<typename V>
        void set(V value) const {
            assert(type_of(V) == type());
            V* target = reinterpret_cast<V*>(address());
            *target = value;
        }

        template<typename V>
        V& get() const {
            assert(type_of(V) == type());
            return *reinterpret_cast<V*>(address());
        }
    };

    class NoSuchFieldException : public std::exception {

    };

    class Callable {
    public:
        virtual TypeInfo& return_type() const = 0;
        virtual const Range<TypeInfo> parameter_types() const = 0;
        virtual void* address() const = 0;
    };

#ifndef NDEBUG
    inline void insight_assert_valid_types(Range<TypeInfo> types, std::initializer_list<TypeInfo*> list) {
        auto expected = types.begin();
        auto actual = list.begin();
        for (; expected != types.end() && actual != list.end(); ++expected, ++actual) {
            assert(*expected == **actual);
        }
    }
#endif

    class MethodInfo : virtual public Callable, virtual public MemberInfo {
    public:
        virtual bool is_virtual() const = 0;
        virtual size_t vtable_index() const = 0;

        template<typename R, typename T, typename ...Args>
        R call(T& instance, Args... args) const {
            assert(type_of(T) == declaring_type());
#ifndef NDEBUG
            insight_assert_valid_types(parameter_types(), { (&type_of(Args))... });
#endif

            using FuncType = R (*)(T*, Args...);
            FuncType func;
            if (is_virtual()) {
                FuncType* vtable = *reinterpret_cast<FuncType**>(&instance);
                func = vtable[vtable_index()];
            } else {
                void* addr = address();
                if (!addr)
                    throw std::runtime_error("No address for function " + name());
                func = reinterpret_cast<FuncType>(addr);
            }
            return func(&instance, args...);
        }
    };

    class FunctionInfo : virtual public Callable, virtual public Named {
    public:

        template<typename R, typename ...Args>
        R call(Args... args) const {
#ifndef NDEBUG
            insight_assert_valid_types(parameter_types(), { (type_of(Args))... });
#endif

            using FuncType = R (*)(Args...);
            void* addr = address();
            if (!addr)
                throw std::runtime_error("No address for function " + name());
            FuncType func = reinterpret_cast<FuncType>(addr);
            return func(args...);
        }
    };

    class Container : virtual public Named, virtual public Child {
    public:
        virtual const Range<FunctionInfo> functions() const = 0;
        virtual FunctionInfo& function(std::string name) const = 0;
        virtual const Range<VariableInfo> variables() const = 0;
        virtual VariableInfo& variable(std::string name) const = 0;
        virtual const Range<TypeInfo> types() const = 0;
        virtual TypeInfo& type(std::string name) const = 0;

        virtual bool operator==(const Container& other) const = 0;
    };

    class StructInfo : virtual public TypeInfo, virtual public Container {
    public:
        virtual const Range<MethodInfo> methods() const = 0;
        virtual MethodInfo& method(std::string name) const = 0;
        virtual const Range<FieldInfo> fields() const = 0;
        virtual FieldInfo& field(std::string name) const = 0;
        virtual const WeakRange<TypeInfo> supertypes() const = 0;
        virtual TypeInfo& supertype(std::string name) const = 0;

        virtual bool operator==(const Container& other) const override {
            if (const TypeInfo* o = dynamic_cast<const TypeInfo*>(&other))
                return TypeInfo::operator==(*o);
            return false;
        }
    };

    class PointerTypeInfo : virtual public TypeInfo {
    public:
        virtual TypeInfo& pointed_type() const = 0;
    };

    class ConstTypeInfo : virtual public TypeInfo {
    public:
        virtual TypeInfo& type() const = 0;
    };

    class TypeDefInfo : virtual public TypeInfo {
    public:
        virtual TypeInfo& aliased_type() const = 0;
    };

    class NamespaceInfo : virtual public Container {
    public:
        virtual const Range<NamespaceInfo> nested_namespaces() const = 0;
        virtual NamespaceInfo& nested_namespace(std::string name) const = 0;

        virtual bool operator==(const Container& other) const override {
            if (const NamespaceInfo* o = dynamic_cast<const NamespaceInfo*>(&other)) {
                // stop recursing on the root namespace
                if (name().length() == 0)
                    return o->name().length() == 0;
                return name() == o->name() && parent() == o->parent();
            }
            return false;
        }
    };

    inline bool TypeInfo::operator==(const TypeInfo& rhs) const {
        return name() == rhs.name() && parent() == rhs.parent();
    }

    inline StructInfo& MemberInfo::declaring_type() const {
        return dynamic_cast<StructInfo&>(parent());
    }
}

#endif /* !INSIGHT_TYPES_HH */
